# ç¬¬ä¸‰ç« ï¼åŸå‹æ¨¡å¼
****************
Sometimes, we need to create an exact copy of an object. For instance, assume
that you want to create an application for storing, sharing, and editing (such as modifying, adding notes, and removing) culinary recipes. User Bob finds a cake recipe and after making a few modifications he thinks that his cake is delicious, and he wants to share it with his friend, Alice. But what does sharing a recipe mean?
If Bob wants to do some further experimentation with his recipe after sharing it with Alice, will the new changes also be visible in Alice's recipe? Can Bob keep two copies of the cake recipe? His delicious cake recipe should remain unaffected by any changes made in the experimental cake recipe.  

æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªå¯¹è±¡çš„å®Œå…¨æ‹·è´ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä½ æƒ³è¦åˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿå­˜å‚¨ã€åˆ†äº«ã€å’Œç¼–è¾‘çš„ï¼ˆæ¯”å¦‚ï¼Œä¿®æ”¹ï¼Œæ·»åŠ ç¬”è®°ã€åˆ é™¤ç¬”è®°ï¼‰èœè°±åº”ç”¨ã€‚ç”¨æˆ·Bodå‘ç°äº†ä¸€æœ¬ç³•ç‚¹é£Ÿè°±ï¼Œä¹‹åå¯¹ä»–åšå‡ºäº†ä¸€äº›è‡ªè®¤ä¸ºå¯ä»¥è®©è›‹ç³•ç¾å‘³çš„è½»å¾®ä¿®æ”¹ï¼Œè€Œä¸”ä»–è¿˜æƒ³å’Œå¥½å‹çˆ±ä¸½ä¸åˆ†äº«è¿™ä»½é£Ÿè°±ã€‚é‚£ä¹ˆåˆ†äº«é£Ÿè°±æ„å‘³ç€ä»€ä¹ˆå‘¢ï¼Ÿå¦‚æœé²å‹ƒæƒ³è¦åœ¨æŠŠé£Ÿè°±åˆ†äº«ç»™çˆ±ä¸½ä¸ä¹‹åè¿›è¡Œæ·±å…¥å®éªŒï¼Œé‚£ä¹ˆå¯¹é£Ÿè°±çš„æ–°å˜æ›´ä¹Ÿå¯ä»¥å‡ºç°åœ¨çˆ±ä¸½ä¸çš„é£Ÿè°±ä¸­å—ï¼Ÿé²å‹ƒå¯ä»¥æ‹¥æœ‰è›‹ç³•é£Ÿè°±çš„åŒä»½æ‹·è´å—ï¼Ÿä»–çš„ç¾å‘³è›‹ç³•é£Ÿè°±åº”è¯¥ä¸å—åˆ°ä»»ä½•è¯•éªŒæ€§è›‹ç³•é£Ÿè°±ä¿®æ”¹çš„å½±å“ã€‚  

Such problems can be solved by allowing the users to have more than one independent copy of the same recipe. Each copy is called a clone, because it is an exact copy of the original object at a specific point in time. The time aspect is important, since it affects what the clone contains. For example, if Bob shares the cake recipe with Alice before making his own improvements to achieve perfection, Alice will never be able to bake her own version of the delicious cake that Bob created! She will only be able to bake the original cake recipe found by Bob.  

æ­¤ç±»é—®é¢˜å¯ä»¥é€šè¿‡è®©ç”¨æˆ·ä½¿ç”¨ä¸æ­¢ä¸€ä»½ç‹¬ç«‹çš„ç›¸åŒæ‹·è´æ¥è§£å†³ã€‚æ¯ä¸ªæ‹·è´éƒ½ç§°ä½œå…‹éš†ï¼Œå› ä¸ºè¿™ä»½æ‹·è´æ˜¯åœ¨ä¸€ä¸ªæŒ‡å®šå¯¹æ—¶é—´å†…çš„åŸå§‹å¯¹è±¡æ‹·è´ã€‚æ—¶é—´æ–¹é¢å¾ˆé‡è¦ï¼Œå› ä¸ºå®ƒå½±å“ç€å°†è¦å…‹éš†çš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœé²å‹ƒåœ¨æ”¹è¿›é£Ÿè°±å·²å®ç°å®Œç¾ä¹‹å‰å°±æŠŠè›‹ç³•é£Ÿè°±åˆ†äº«ç»™äº†çˆ±ä¸½ä¸ï¼Œé‚£ä¹ˆçˆ±ä¸½ä¸å°±æ°¸è¿œä¸èƒ½å¤Ÿçƒ˜åŸ¹é²å‹ƒæ‰€åˆ›å»ºçš„ç¾å‘³è›‹ç³•çš„ç§æœ‰å®šåˆ¶ç‰ˆæœ¬ï¼å¥¹åªèƒ½å¤Ÿçƒ˜åŸ¹ç”±é²å‹ƒåˆ›å»ºçš„åŸå§‹ç‰ˆæœ¬è›‹ç³•é£Ÿè°±ä¸­çš„è›‹ç³•ã€‚  

Note the difference between a copy and a reference. If we have two references to the same cake recipe, whatever changes Bob makes to the recipe will be visible to Alice's version of the recipe, and vice versa. What we want is both Bob and Alice to have their own copy, so that they can make independent changes without affecting each other's recipe. Bob actually needs two copies of the cake recipe: the delicious version and the experimental version.  

æ³¨æ„æ‹·è´å’Œå¼•ç”¨ä¹‹é—´çš„ä¸åŒã€‚å¦‚æœå¯¹ç›¸åŒçš„ç³•ç‚¹é£Ÿè°±åšäº†ä¸¤ä¸ªå¼•ç”¨ï¼Œä¸è®ºBobå¯¹é£Ÿè°±åšäº†ä»€ä¹ˆæ›´æ”¹ï¼ŒAliceçš„é£Ÿè°±ä¸­éƒ½å¯ä»¥çœ‹åˆ°ï¼Œåä¹‹äº¦ç„¶ã€‚è¦æ˜¯æˆ‘ä»¬æƒ³è®©Bobå’ŒAliceéƒ½æ‹¥æœ‰å„è‡ªçš„æ‹·è´ï¼Œé‚£ä¹ˆä»–ä»¬å°±å¯ä»¥å„è‡ªå˜æ›´è€Œä¸å½±å“åˆ°å¯¹æ–¹çš„é£Ÿè°±ã€‚Bobå®é™…ä¸Šéœ€è¦ç³•ç‚¹é£Ÿè°±çš„ä¸¤ä»½æ‹·è´ï¼šç¾å‘³ç‰ˆå’Œä½“éªŒç‰ˆã€‚   

The difference between a reference and a copy is shown in the following figure:  

å¼•ç”¨å’Œå¤åˆ¶ä¹‹é—´çš„åŒºåˆ«å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š  

![img](images/)  

On the left part, we can see two references. Both Alice and Bob refer to the same recipe, which essentially means that they share it and all modifications are visible by both. On the right part, we can see two different copies of the same recipe. In this case, independent modifications are allowed and the changes of Alice do not affect the changes of Bob, and vice versa.  

åœ¨æœ€åä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸¤ä¸ªå¼•ç”¨ã€‚Aliceå’ŒBodå¼•ç”¨äº†ç›¸åŒçš„é£Ÿè°±ï¼Œè¿™åŸºæœ¬ä¸Šå°±æ„å‘³ç€ä»–ä»¬å…±äº«äº†æ‰€æœ‰çš„å˜æ›´ï¼Œè€Œä¸”è¿™äº›å˜æ›´å½¼æ­¤è¯¾ä»¶ã€‚åœ¨å³è¾¹éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç›¸åŒé£Ÿè°±çš„ä¸¤ä»½ä¸åŒæ‹·è´ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå•ç‹¬çš„ä¿®æ”¹æ˜¯è¢«å…è®¸çš„ï¼ŒAliceçš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ°Booï¼Œåä¹‹äº¦ç„¶ã€‚  

The **Prototype design pattern** helps us with creating object clones. In its simplest version, the Prototype pattern is just a clone() function that accepts an object as an input parameter and returns a clone of it. In Python, this can be done using the copy.deepcopy() function. Let's see an example. In the following code (file clone.py), there are two classes, A and B. A is the parent class and B is the derived class. In the main part, we create an instance of class B b, and use deepcopy() to create a clone of b named c. The result is that all the members of the hierarchy (at the point of time the cloning happens) are copied in the clone c. As an interesting exercise, you can try using deepcopy() with composition instead of inheritance which is shown in the following code:  

åŸå‹è®¾è®¡æ¨¡å¼æœ‰åŠ©äºæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå¯¹è±¡çš„å…‹éš†ã€‚åœ¨å…¶æœ€ç®€å•ç‰ˆæœ¬ä¸­ï¼ŒåŸå‹æ¨¡å¼åªæ˜¯ä¸€ä¸ªæ¥å—å¯¹è±¡ä½œä¸ºè¾“å…¥å‚æ•°å¹¶è¿”å›è¿™ä¸ªå¯¹è±¡å…‹éš†çš„clone()å‡½æ•°ã€‚åœ¨Pythonä¸­ï¼Œå¯ä»¥ä½¿ç”¨copy.deepcopy()å‡½æ•°å®ç°æ­¤ç›®çš„ã€‚è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­ï¼ˆæ–‡ä»¶clone.pyï¼‰ï¼Œç”±ä¸¤ä¸ªç±»Aå’ŒBã€‚Aæ˜¯ä¸€ä¸ªçˆ¶ç±»è€ŒBæ˜¯ä¸€ä¸ªæ´¾ç”Ÿç±»ã€‚åœ¨ä¸»ä½“éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªç±»Bçš„å®ä¾‹bï¼Œå¹¶ä½¿ç”¨äº†deepcopy()åˆ›å»ºäº†ä¸€ä¸ªå«åšcçš„å®ä¾‹bçš„å…‹éš†ã€‚

```python
import copy


class A:
    def __init__(self):
        self.x = 18
        self.msg = 'Hello'


class B(A):
    def __init__(self):
        A.__init__(self)
        self.y = 34
    def __str__(self):
           return '{}, {}, {}'.format(self.x, self.msg, self.y)


if __name__ == '__main__':
    b = B()
    c = copy.deepcopy(b)
    print([str(i) for i in (b, c)])
    print([i for i in (b, c)])
```

When executing clone.py on my computer, I get the following:  

å½“ä½ æ‰§è¡Œclone.pyåï¼Œè¾“å‡ºå†…å®¹æ˜¯ï¼š  

```python

>>> python3 clone.py
['18, Hello, 34', '18, Hello, 34']
[<__main__.B object at 0x7f92dac33240>, <__main__.B object at
0x7f92dac33208>]
```

Although your output of the second line will most likely not be the same as mine, what's important is to notice that the two objects reside in two different memory addresses (the 0x... part). This means that the two objects are two independent copies.  

è™½ç„¶ä½ çš„ç¬¬äºŒè¡Œçš„è¾“å‡ºå’Œæˆ‘çš„æœ‰ç€å¾ˆå¤§çš„ä¸åŒï¼Œé‡è¦çš„åœ¨äºæ³¨æ„è¿™ä¸¤ä¸ªå¯¹è±¡ä½äºä¸¤ä¸ªä¸åŒçš„å†…å­˜åœ°å€ä¸­ï¼ˆ0x...é‚£ä¸€éƒ¨åˆ†ï¼‰ã€‚è¿™å°±æ„å‘³ç€ä¸¤ä¸ªå¯¹è±¡æ˜¯ä¸¤ä»½ç‹¬ç«‹çš„å‰¯æœ¬ã€‚  

In the Implementation section, later in this chapter, we will see how to use `copy. deepcopy()` with some extra boilerplate code wrapped in a class, for keeping a registry of the objects that are cloned.  

åœ¨æœ¬ç« ç¨åçš„å®ç°å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å¦‚ä½•ä½¿ç”¨`copy. deepcopy()`

## A real-life example
The Prototype design pattern is all about cloning an object. Mitosis, the process in a cell division by which the nucleus divides resulting in two new nuclei, each of which has exactly the same chromosome and DNA content as the original cell, is an example of biological cloning [j.mp/mmitosis].  

åŸå‹è®¾è®¡æ¨¡å¼å…¨éƒ½æ˜¯å…³äºå…‹éš†ä¸€ä¸ªå¯¹è±¡çš„ã€‚

The following figure, provided by www.sourcemaking.com, shows an example of the mitotic division of a cell [j.mp/pprotpat]:  

åœ¨ä¸‹é¢çš„ç”±www.sourcemaking.comæä¾›çš„å›¾è¡¨ä¸­ï¼Œ

å›¾ç‰‡ï¼šç•¥  

Another popular example of (artificial) cloning is Dolly, the sheep [j.mp/wikidolly].  

å¦å¤–ä¸€ä¸ªæµè¡Œçš„å…‹éš†æ¡ˆä¾‹æ˜¯å¤šè‰ç¾ŠğŸ‘ã€‚  

## A software example
There are many Python applications that make use of the Prototype pattern [j.mp/ pythonprot], but it is almost never referred to as Prototype since cloning objects
is a built-in feature of the language.  

æœ‰å¾ˆå¤šçš„Pythonåº”ç”¨ä½¿ç”¨äº†åŸå‹æ¨¡å¼ï¼Œä½†å‡ ä¹ä»ä¸æåŠåŸå‹ï¼Œå› ä¸ºå…‹éš†å¯¹è±¡æ˜¯è¿™é—¨è¯­è¨€çš„ä¸€ä¸ªå†…ç½®åŠŸèƒ½ã€‚  

One application that uses Prototype is the **Visualization Toolkit (VTK)** [j.mp/pyvto]. VTK is an open source cross-platform system for 3D computer graphics, image processing, and visualization. VTK uses Prototype for creating clones of geometrical elements such as points, lines, hexahedrons, and so forth [j.mp/vtkcell].  

Another project that uses Prototype is **music21**. According to the project's page, "music21 is a set of tools for helping scholars and other active listeners answer questions about music quickly and simply" [j.mp/pmusic21]. The music21 toolkit uses Prototype for copying musical notes and scores [j.mp/py21code].  

## Use cases
The Prototype pattern is useful when we have an existing object and we want to create an exact copy of it. A copy of an object is usually required when we know that parts of the object will be modified but we want to keep the original object untouched. In such cases, it doesn't make sense to recreate the original object from scratch [j.mp/protpat].  

å½“æˆ‘ä»¬æ‹¥æœ‰ä¸€ä¸ªç°æœ‰å¯¹è±¡ï¼Œè€Œä¸”æƒ³è¦åˆ›å»ºä¸€ä¸ªæ­¤å¯¹è±¡çš„å®Œå…¨æ‹·è´æ—¶åŸå‹æ¨¡å¼å°±å¾ˆæœ‰ç”¨äº†ã€‚

Another case where Prototype comes in handy is when we want to duplicate a complex object. By duplicating a complex object, we can think of an object that is populated from a database and has references to other objects that are also populated from a database. It is a lot of effort to create an object clone by querying the database(s) multiple times again. Using Prototype for such cases is more convenient.  

So far, we have covered only the reference versus copy issue, but a copy can be further divided into a deep copy versus a shallow copy. A deep copy is what we
have seen so far: all data of the original object are simply copied in the clone, without making any exceptions. A shallow copy relies on references. We can introduce data sharing, and techniques like copy-on-write to improve the performance (such as clone creation time) and the memory usage. Using shallow copies might be worthwhile if the available resources are limited (such as embedded systems) or performance is critical (such as high-performance computing).  

åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªè¯´åˆ°äº†å¼•ç”¨ä¸å¤åˆ¶çš„é—®é¢˜ï¼Œä½†æ˜¯å¤åˆ¶åˆè¢«è¿›ä¸€æ­¥åˆ†ä¸ºæ·±æ‹·è´å’Œæµ…æ‹·è´ã€‚æˆ‘ä»¬ç›®å‰æ‰€è§åˆ°çš„æ·±æ‹·è´æ˜¯ï¼š

In Python, we can do shallow copies using the copy.copy() function. Quoting the official Python documentation, the differences between a shallow copy (copy. copy()) and a deep copy (copy.deepcopy()) in Python are [j.mp/py3copy]
as follows:  

åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‡½æ•°copy.copy()æ‰§è¡Œæµ…æ‹·è´ã€‚å¼•ç”¨Pythonå®˜æ–¹æ–‡æ¡£æ¥è¯´ï¼ŒPythonä¸­çš„æµ…æ‹·è´å’Œæ·±æ‹·è´çš„åŒºåˆ«åœ¨äºä»¥ä¸‹ä¸¤ç‚¹ï¼š  

- "A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.  

- A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original."  

- â€œâ€
- 

Can you think of any examples where using shallow copies is better than using deep copies?  

## Implementation å®ç°
In programming, it is not uncommon for a book to be available in multiple editions. For example, the classic textbook on C programming The C Programming Language by Kernighan and Ritchie is available in two editions. The first edition was published in 1978. At that time, C was not standardized. The second edition of the book was published 10 years later and covers the standard (ANSI) version of C. What are the differences between the two editions? To mention a few, the price, the length (number of pages), and the publication date. But there are also many similarities: the authors, the publishers, and the tags/keywords that describe the book are exactly the same. This indicates that creating a new book from scratch is not always the best approach. If we know that there are many similarities between two book editions, we can use cloning and modify only the different parts of the new edition.  

Let's see how we can use the Prototype pattern for creating an application that shows book information. We begin with the representation of a book. Apart from the usual initialization, the Book class demonstrates an interesting technique. It shows how we can avoid the telescopic constructor problem. In the `__init__()` method, only three parameters are fixed: name, authors, and price. But clients can pass more parameters in the form of keywords (name=value) using the rest variable-length list. The line `self.__dict__.update(rest)` adds the contents of rest to the internal dictionary of the Book class to make them part of it.  

But there's a catch. Since we don't know all the names of the added parameters, we need to access the internal dict for making use of them in `__str__()`. And since the contents of a dictionary do not follow any specific order, we use an OrderedDict to force an order; otherwise, every time the program is executed, different outputs will be shown. Of course, you should not take my words for granted. As an exercise, remove the usage of OrderedDict and sorted() and run the example to see if I'm right:  

```python
class Book:
    def __init__(self, name, authors, price, **rest):
       '''Examples of rest: publisher, length, tags, publication
       date'''
       self.name = name
       self.authors = authors
       self.price = price      # in US dollars
       self.__dict__.update(rest)
    def __str__(self):
       mylist=[]
       ordered = OrderedDict(sorted(self.__dict__.items()))
       for i in ordered.keys():
           mylist.append('{}: {}'.format(i, ordered[i]))
           if i == 'price':
               mylist.append('$')
           mylist.append('\n')
       return ''.join(mylist)

```

The `Prototype` class implements the Prototype design pattern. The heart of the Prototype class is the clone() method, which does the actual cloning using the familiar copy.deepcopy() function. But the Prototype class does a bit more than supporting cloning. It contains the register() and unregister() methods, which can be used to keep track of the objects that are cloned in a dictionary. Note that this is just a convenience, and not a necessity.  


Moreover, the `clone()` method uses the same trick that `__str__()` uses in the Book class, but this time for a different reason. Using the variable-length list attr, we can pass only the variables that really need to be modified when cloning an object as follows:  

```python
class Prototype:
       def __init__(self):
           self.objects = dict()
       def register(self, identifier, obj):
           self.objects[identifier] = obj
       def unregister(self, identifier):
           del self.objects[identifier]
       def clone(self, identifier, **attr):
           found = self.objects.get(identifier)
           if not found:
               raise ValueError('Incorrect object identifier:{}'.format(identifier))
           obj = copy.deepcopy(found)
           obj.__dict__.update(attr)
           return obj
```

The `main()` function shows The C Programming Language book cloning example mentioned at the beginning of this section in practice. When cloning the first edition of the book to create the second edition, we only need to pass the modified values of the existing parameters. But we can also pass extra parameters. In this case, edition is a new parameter that was not needed in the first book but is useful information for the clone:  

```python
def main():
       b1 = Book('The C Programming Language', ('Brian W. Kernighan',
       'Dennis M.Ritchie'), price=118, publisher='Prentice Hall',
       length=228, publication_date='1978-02-22', tags=('C',
       'programming', 'algorithms', 'data structures'))
       prototype = Prototype()
       cid = 'k&r-first'
       prototype.register(cid, b1)
       b2 = prototype.clone(cid, name='The C Programming Language(ANSI)', price=48.99, length=274,
       publication_date='1988-04-01', edition=2)
       for i in (b1, b2):
           print(i)
       print("ID b1 : {} != ID b2 : {}".format(id(b1), id(b2)))
```


Notice the usage of the id() function which returns the memory address of an object. When we clone an object using a deep copy, the memory addresses of the clone must be different from the memory addresses of the original object.  

The `prototype.py` file is as follows:  

```python
import copy
from collections import OrderedDict


   class Book:
       def __init__(self, name, authors, price, **rest):
           '''Examples of rest: publisher, length, tags, publication
           date'''
           self.name = name
           self.authors = authors
           self.price = price      # in US dollars
           self.__dict__.update(rest)
       def __str__(self):
           mylist=[]
           ordered = OrderedDict(sorted(self.__dict__.items()))
           for i in ordered.keys():
               mylist.append('{}: {}'.format(i, ordered[i]))
               if i == 'price':
                   mylist.append('$')
               mylist.append('\n')
           return ''.join(mylist)


   class Prototype:
       def __init__(self):
           self.objects = dict()
       def register(self, identifier, obj):
           self.objects[identifier] = obj
       def unregister(self, identifier):
           del self.objects[identifier]
       def clone(self, identifier, **attr):
           found = self.objects.get(identifier)
           if not found:
               raise ValueError('Incorrect object identifier:{}'.format(identifier))
           obj = copy.deepcopy(found)
           obj.__dict__.update(attr)
            return obj


   def main():
       b1 = Book('The C Programming Language', ('Brian W. Kernighan',
       'Dennis M.Ritchie'), price=118, publisher='Prentice Hall',
       length=228, publication_date='1978-02-22', tags=('C',
       'programming', 'algorithms', 'data structures'))
       prototype = Prototype()
       cid = 'k&r-first'
       prototype.register(cid, b1)
       b2 = prototype.clone(cid, name='The C Programming Language (ANSI)', price=48.99, length=274,
       publication_date='1988-04-01', edition=2)
       for i in (b1, b2):
           print(i)
       print("ID b1 : {} != ID b2 : {}".format(id(b1), id(b2)))


   if __name__ == '__main__':
       main()
```

The output of id() depends on the current memory allocation of the computer and you should expect it to differ on every execution of this program. But no matter what the actual addresses are, they should not be the same in any chance.  

A sample output when I execute this program on my machine is as follows:  

```python
>>> python3 prototype.py
authors: ('Brian W. Kernighan', 'Dennis M. Ritchie')
length: 228
name: The C Programming Language
price: 118$
publication_date: 1978-02-22
publisher: Prentice Hall
tags: ('C', 'programming', 'algorithms', 'data structures')

authors: ('Brian W. Kernighan', 'Dennis M. Ritchie')
edition: 2
length: 274
name: The C Programming Language (ANSI)
price: 48.99$
publication_date: 1988-04-01
publisher: Prentice Hall
tags: ('C', 'programming', 'algorithms', 'data structures')
ID b1 : 140004970829304 != ID b2 : 140004970829472
```

Indeed, Prototype works as expected. The second edition of The C Programming Language book reuses all the information that was set in the first edition, and all the differences that we defined are only applied to the second edition. The first edition remains unaffected. Our confidence can be increased by looking at the output of the id() function: the two addresses are different.  

As an exercise, you can come up with your own example of Prototype. A few ideas are as follows:  

- The recipe example that was mentioned in this chapter  
- The database-populated object that was mentioned in this chapter  
- Copying an image so that you can add your own modifications without touching the original  

## Summary æ€»ç»“
In this chapter, we have seen how to use the Prototype design pattern. Prototype is used for creating exact copies of objects. Creating a copy of an object can actually mean two things:  

æœ¬ç« ï¼Œæˆ‘ä»¬è§åˆ°äº†å¦‚ä½•å¦‚ä½•ä½¿ç”¨åŸå‹è®¾è®¡æ¨¡å¼ã€‚åŸå‹ç”¨æ¥åˆ›å»ºç²¾ç¡®åœ°å¯¹è±¡å‰¯æœ¬ã€‚åˆ›å»ºä¸€ä¸ªå¯¹è±¡çš„å‰¯æœ¬å®é™…ä¸Šæ„å‘³ç€ä¸¤ä»¶äº‹æƒ…ï¼š  

- Relying on references, which happens when a shallow copy is created  
- å½“æ‰§è¡Œæµ…æ‹·è´æ—¶ï¼Œè§†æ‰€å¼•ç”¨çš„åŸå§‹å†…å®¹è€Œå®šã€‚  

- Duplicating everything, which happens when a deep copy is created  
- åœ¨æ‰§è¡Œæ·±æ‹·è´æ—¶ï¼Œé‡å¤æ‰€æœ‰å†…å®¹ã€‚ 

In the first case, we want to focus on improving the performance and the memory usage of our application by introducing data sharing between objects. But we need to be careful about modifying data, because all modifications are visible to all copies. Shallow copies were not introduced in this chapter, but you might want to experiment with them.  

åœ¨ç¬¬ä¸€ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›å°†æ³¨æ„åŠ›æ”¾åœ¨é€šè¿‡å¼•å…¥å¯¹è±¡ä¹‹é—´çš„æ•°æ®å…±äº«å¯¹ä»¥æé«˜æ€§èƒ½ä»¥åŠå†…å­˜åˆ©ç”¨ä¸Šé¢ã€‚ä½†æ˜¯ä¿®æ”¹æ•°æ®æ—¶æˆ‘ä»¬éœ€è¦ç‰¹åˆ«å°å¿ƒï¼Œå› ä¸ºè¿™äº›ä¿®æ”¹å¯¹äºæ‰€æœ‰çš„å¤åˆ¶éƒ½æ˜¯å¯è§çš„ã€‚æœ¬ç« æˆ‘ä»¬ä¸ä¼šä»‹ç»æµ…æ‹·è´çš„ï¼Œä¸è¿‡ä½ å¯ä»¥è‡ªå·±äº†è§£äº†è§£ã€‚

In the second case, we want to be able to make modifications to one copy without affecting the rest. That is useful for cases like the cake-recipe example that we have seen. Here, no data sharing is done and so we need to be careful about the resource consumption and the overhead that is introduced by our clones.  

åœ¨ç¬¬äºŒä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¾æ˜‚èƒ½å¤Ÿä¿®æ”¹ä¸€ä¸ªå‰¯æœ¬è€Œä¸ä¼šå½±å“åˆ°ä½™ä¸‹çš„å‰¯æœ¬ã€‚

We showed a simple example of a deep copying which in Python is done using the copy.deepcopy() function. We also mentioned examples of cloning found in real life, focusing on mitosis.  

æˆ‘ä»¬æ¼”ç¤ºäº†åœ¨Pythonä¸­ä½¿ç”¨copy.deepcopy()å‡½æ•°çš„æ·±æ‹·è´çš„ç®€å•ä¾‹å­ã€‚æˆ‘ä»¬ä¹Ÿè°ˆåˆ°äº†çœŸå®ç”Ÿæ´»ä¸­å­˜åœ¨çš„ä¸€ä¸ªå…³äºå…‹éš†å¯»æ‰¾çš„ä¾‹å­ï¼Œå³ç»†èƒçš„æœ‰ä¸åˆ†è£‚ã€‚  

Many software projects use Prototype, but in Python it is not mentioned as such because it is a built-in feature. Among them are the VTK, which uses Prototype for creating clones of geometrical elements, and music21, which uses it for duplicating musical scores and notes.   

å¾ˆå¤šçš„è½¯ä»¶æƒ³éƒ½ç”¨åˆ°äº†åŸå‹ï¼Œä½†æ˜¯åœ¨Pythonä¸­å®ƒå´å¹¶æœªè¢«æåŠï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå†…å»ºçš„åŠŸèƒ½ã€‚

Finally, we discussed the use cases of Prototype and implemented a program that supports cloning books so that all information that does not change in a new edition can be reused, but at the same time modified information can be updated and new information can be added.  

æœ€åï¼Œæˆ‘ä»¬è®¨è®ºäº†åŸå‹çš„ä½¿ç”¨æ¡ˆä¾‹ï¼Œå®ç°äº†ä¸€ä¸ªæ”¯æŒå…‹éš†ç™»è®°çš„ä¾‹å­ï¼Œè¿™æ ·åœ¨ä¸€ä¸ªèƒ½å¤Ÿé‡å¤ä½¿ç”¨çš„æ–°ç‰ˆæœ¬ä¸­æ‰€æœ‰çš„ä¿¡æ¯éƒ½ä¸ä¼šè¢«æ”¹å˜ï¼Œä½†æ˜¯åœ¨åŒä¸€æ—¶é—´ä¿®æ”¹çš„ä¿¡æ¯èƒ½å¤Ÿè¢«æ›´æ–°è€Œä¸”æ–°ä¿¡æ¯ä¹Ÿå¯ä»¥å¢åŠ ã€‚  

Prototype is the last creational design pattern covered in this book. The next chapter begins with Adapter, a structural design pattern that can be used to make two incompatible software interfaces compatible.  

åŸå‹



